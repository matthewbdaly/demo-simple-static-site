<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta property="fb:app_id" content=""/>
        <link rel="stylesheet" type="text/css" href="/static/bower_components/bootstrap-sass/dist/css/bootstrap.min.css" media="all" />
        <link rel="stylesheet" type="text/css" href="/static/bower_components/flat-ui/dist/css/flat-ui.min.css" media="all" />
        <link rel="stylesheet" type="text/css" href="/static/bower_components/highlightjs/styles/zenburn.css" media="all" />
        <link rel="alternate" type="application/rss+xml" title="A Series of Quite Extraordinary Events - feed" href="/index.xml" />
        <title>A Series of Quite Extraordinary Events - Django blog tutorial - the next generation - part 2</title>
    </head>
    <body>
        <header>
            <div class="container">
                <div class="page-header">
                    <h1>A Series of Quite Extraordinary Events</h1>
                    <h2>Being the blog of Matthew Daly Esquire</h2>
                    <nav>
                        <a href="/">Home</a> | <a href="/archive.html">Archives</a> | <a href="/about.html">About</a> | <a href="/rss.xml">RSS</a>
                    </nav>
                </div>
            </div>
        </header>

        <div class="container">
            <article class="post">
    
  <div class="title">
    <h1><a href="/posts/2014-01-02-django-blog-tutorial-the-next-generation-part-2.html">Django blog tutorial - the next generation - part 2</a></h1>
  </div>
  <section>
    <p>Welcome back! In this lesson, we&#39;ll use Twitter Bootstrap to make our blog look nicer, and we&#39;ll implement individual pages for each post.</p>
<p>Now, before we get started, don&#39;t forget to switch into your virtualenv. From within the directory for the project, run the following command:</p>
<pre><code class="lang-bash">source venv/bin/activate</code></pre>
<p>If you haven&#39;t used Bootstrap before, you&#39;re in for a treat. With Bootstrap, it&#39;s easy to make a good-looking website quickly that&#39;s responsive and mobile-friendly. We&#39;ll also use HTML5 Boilerplate to get a basic HTML template in place.</p>
<p>Now, to install these easily, we&#39;ll use Bower, which requires <a href="http://nodejs.org/">Node.js</a>. Install Node.js first. On most Linux distros, you&#39;ll also need to set <code>NODE_PATH</code>, which can be done by pasting the following into your <code>.bashrc</code>:</p>
<p>``` bash .bashrc
NODE_PATH=&quot;/usr/local/lib/node_modules&quot;</p>
<pre><code>
With <span class="keyword">that</span> done, <span class="command">run</span> <span class="keyword">the</span> following command <span class="keyword">to</span> install Bower:

``` bash
sudo npm install -g bower</code></pre>
<p>Next we need to create a Bower config. First, create the folder <code>blogengine/static</code>. Then create a new file called <code>.bowerrc</code> and paste in the following content:</p>
<p>``` json .bowerrc
{
    &quot;directory&quot;: &quot;blogengine/static/bower_components&quot;
}</p>
<pre><code>
This tells Bower <span class="keyword">where</span> <span class="keyword">it</span> should <span class="keyword">put</span> downloaded libraries. Next, <span class="command">run</span> <span class="keyword">the</span> following command <span class="keyword">to</span> gener Bower:

``` bash
bower init</code></pre>
<p>Answer all the questions it asks you - for those with defaults, these should be fine, and everything else should be easy enough. Next, run the following command to install Bootstrap and HTML5 Boilerplate:</p>
<pre><code class="lang-bash">bower install bootstrap html5-boilerplate --save</code></pre>
<p>Note that as jQuery is a dependency of Bootstrap, it will also be installed automatically. Now, we need to keep our Bower-installed files out of version control - the <code>bower.json</code> file keeps track of them for us. So add the following to your .gitignore file:</p>
<p>``` bash .gitignore
blogengine/static/bower_components/</p>
<pre><code>
All done? Let's <span class="operator"><span class="keyword">commit</span> our changes:

<span class="string">``</span><span class="string">` bash
git add .gitignore .bowerrc bower.json
git commit -m 'Added Bower config'</code></pre>
<p>Now, let&#39;s make our template nicer. Django&#39;s templating system is very powerful and lets one template inherit from another. We&#39;re going to create a base template, using HTML5 Boilerplate as a starting point, that all of our web-facing pages will use. First, create a directory to hold the base template:</p>
<pre><code class="lang-bash">mkdir templates/blogengine/includes</code></pre>
<p>Then copy the <code>index.html</code> file from HTML5 Boilerplate to this directory as <code>base.html</code>:</p>
<pre><code class="lang-bash">cp blogengine/static/bower_components/html5-boilerplate/index.html templates/blogengine/includes/base.html</code></pre>
<p>Now amend this file to look like this:</p>
<p>``` html templates/blogengine/includes/base.html
&lt;!DOCTYPE html&gt;
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">{% raw %}
        <title>{% block title %}My Django Blog{% endblock %}</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1"></p>
<pre><code><span class="xml">    <span class="comment">&lt;!-- Place favicon.ico and apple-touch-icon.png in the root directory --&gt;</span>

    {% load staticfiles %}
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"{% static 'bower_components/html5-boilerplate/css/normalize.css' %}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"{% static 'bower_components/html5-boilerplate/css/main.css' %}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"{% static 'bower_components/bootstrap/dist/css/bootstrap.min.css' %}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"{% static 'bower_components/bootstrap/dist/css/bootstrap-theme.min.css' %}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"{% static 'bower_components/html5-boilerplate/js/vendor/modernizr-</span><span class="number">2.6</span><span class="xml"></span><span class="number">.2</span><span class="xml">.min.js' %}"&gt;<span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="comment">&lt;!--[if lt IE </span><span class="number">7</span><span class="xml">]&gt;
        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"browsehappy"</span>&gt;</span>You are using an <span class="tag">&lt;<span class="title">strong</span>&gt;</span>outdated<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> browser. Please <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://browsehappy.com/"</span>&gt;</span>upgrade your browser<span class="tag">&lt;/<span class="title">a</span>&gt;</span> to improve your experience.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">![endif]--</span>&gt;</span>

    <span class="comment">&lt;!-- Add your site or application content here --&gt;</span>
    {% block content %}{% endblock %}

    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//ajax.googleapis.com/ajax/libs/jquery/</span><span class="number">1.10</span><span class="xml"></span><span class="number">.2</span><span class="xml">/jquery.min.js"&gt;<span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">window.jQuery || document.write(<span class="string">'&lt;script src="{% static '</span>bower_components/html5-boilerplate/js/vendor/jquery-</span></span><span class="number">1.10</span><span class="xml"></span><span class="number">.2</span><span class="xml">.min.js' %}"&gt;<span class="tag">&lt;<span class="title">\</span>/<span class="attribute">script</span>&gt;</span>')<span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"{% static 'bower_components/html5-boilerplate/js/plugins.js' %}"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"{% static 'bower_components/bootstrap/dist/js/bootstrap.min.js' %}"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

    <span class="comment">&lt;!-- Google Analytics: change UA-XXXXX-X to be your site's ID. --&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
        (<span class="keyword">function</span>(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        <span class="keyword">function</span>(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+<span class="keyword">new</span> Date;
        e=o.createElement(i);r=o.getElementsByTagName(i)[</span></span><span class="number">0</span><span class="xml">];
        e.src='//www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
        ga('create','UA-XXXXX-X');ga('send','pageview');
    <span class="tag">&lt;/<span class="title">script</span>&gt;</span>{% endraw %}
<span class="tag">&lt;/<span class="title">body</span>&gt;</span></span></code></pre>
<p></html></p>
<pre><code>
Note the following:

* We need to use `<span class="template_tag">{% raw %}</span><span class="template_tag">{% <span class="keyword">load</span> staticfiles %}</span><span class="template_tag">{% endraw %}</span>` to be able to load any static files.
* We use the <span class="template_tag">{% raw %}</span>`<span class="template_tag">{% <span class="keyword">static</span> %}</span>`<span class="template_tag">{% endraw %}</span> template tag to load static files such as CSS and HTML
* We define blocks called `title` and `content`. Any template that extends this one can override whatever is inside this template.

Please note that HTML5 Boilerplate may conceivable change in future, so bear in mind that all you really need to do is load the staticfiles app, use the `static` tag for any static files that need to be loaded, and define the blocks in the appropriate places.

Next, let's amend our existing template to inherit from this one:

``` html templates/blogengine/post_list.html
<span class="template_tag">{% raw %}</span><span class="template_tag">{% <span class="keyword">extends</span> "blogengine/includes/base.html" %}</span>

    <span class="template_tag">{% <span class="keyword">block</span> content %}</span>
        <span class="template_tag">{% <span class="keyword">for</span> post <span class="keyword">in</span> object_list %}</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="variable">{{ post.title }}</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h3</span>&gt;</span><span class="variable">{{ post.pub_date }}</span><span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
        <span class="variable">{{ post.text }}</span>
        <span class="template_tag">{% <span class="keyword">endfor</span> %}</span>
    <span class="template_tag">{% <span class="keyword">endblock</span> %}</span><span class="template_tag">{% endraw %}</span></code></pre>
<p>Now fire up the server with <code>python manage.py runserver</code> and check everything is working OK. You should see that your new base template is now in use and the CSS and JS files are being loaded correctly. Let&#39;s commit again:</p>
<pre><code class="lang-bash">git add templates/
git commit -m <span class="string">'Now use Bootstrap and HTML5 Boilerplate for templates'</span></code></pre>
<p>Now, let&#39;s use Bootstrap to style our blog a little. First we&#39;ll add a navigation bar at the top of our blog. Edit the base template as follows:</p>
<p>``` html templates/blogengine/includes/base.html
        {% raw %}<div class="navbar navbar-static-top navbar-inverse">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="/">My Django Blog</a>
                    <div class="nav-collapse collapse">
                    </div>
                </div>
            </div>
        </div></p>
<pre><code>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">block</span> header %}</span>
            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"page-header"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">h1</span>&gt;</span>My Django Blog<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endblock</span> %}</span>

        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span>
            <span class="template_tag">{% <span class="keyword">block</span> content %}</span><span class="template_tag">{% <span class="keyword">endblock</span> %}</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>

    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container footer"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"span12"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">p</span>&gt;</span>Copyright &amp;copy; <span class="template_tag">{% <span class="keyword">now</span> "Y" %}</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="template_tag">{% endraw %}</span></code></pre>
<pre><code>
Note the footer copyright section. Here we output the current year using `now`. Also note the addition of the header block. This will let us override the page header if necessary.

We'll also wrap the posts in a div:

``` html templates/blogengine/post_list.html
<span class="template_tag">{% raw %}</span><span class="template_tag">{% <span class="keyword">extends</span> "blogengine/includes/base.html" %}</span>

    <span class="template_tag">{% <span class="keyword">block</span> content %}</span>
        <span class="template_tag">{% <span class="keyword">for</span> post <span class="keyword">in</span> object_list %}</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="variable">{{ post.title }}</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h3</span>&gt;</span><span class="variable">{{ post.pub_date }}</span><span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
        <span class="variable">{{ post.text }}</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endfor</span> %}</span>
    <span class="template_tag">{% <span class="keyword">endblock</span> %}</span><span class="template_tag">{% endraw %}</span></code></pre>
<p>Let&#39;s commit our changes:</p>
<pre><code class="lang-bash">git add templates/
git commit -m <span class="string">'Amended templates'</span></code></pre>
<h2 id="formatting-our-content">Formatting our content</h2>
<p>As it stands right now, we can&#39;t do much to format our posts. It is possible to include HTML in our posts with Django, but by default it will strip it out. Also, we don&#39;t want users to have to write HTML manually - we want to make our blog user friendly!</p>
<p>There are two possible approaches. One is to embed a rich text editor like TinyMCE in the admin and use that for editing the files, but I&#39;ve found things like that to be cumbersome. The alternative is to use some other form of lightweight markup, and that&#39;s the approach we&#39;ll take here. We&#39;re going to use Markdown for editing our posts.</p>
<p>Django has actually dropped support for Markdown, but it&#39;s not hard to implement your own version. First, install Markdown and add it to your <code>requirements.txt</code>:</p>
<pre><code class="lang-bash">pip install markdown
pip freeze &gt; requirements.txt</code></pre>
<p>Now, we shouldn&#39;t write any production code before writing a test, so let&#39;s amend our existing post test to check to see that Markdown is working as expected:</p>
<p>``` python blogengine/tests.py
class PostViewTest(LiveServerTestCase):
    def setUp(self):
        self.client = Client()</p>
<pre><code>def test_index(self):
    # Create the post
    post = Post()
    post.title = <span class="comment">'My first post'</span>
    post.text = <span class="comment">'This is [my first blog post](http://127.0.0.1:8000/)'</span>
    post.pub_date = timezone.<span class="built_in">now</span>()
    post.save()

    # Check <span class="keyword">new</span> post saved
    all_posts = Post.objects.all()
    self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)

    # Fetch the index
    <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/')</span>
    self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

    # Check the post title <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(post.title <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post text <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(markdown.markdown(post.text) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post <span class="built_in">date</span> <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">year</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)
    self.assertTrue(post.pub_date.strftime(<span class="comment">'%b') in response.content)</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">day</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the link <span class="keyword">is</span> marked up properly
    self.assertTrue(<span class="comment">'&lt;a href="http://127.0.0.1:8000/"&gt;my first blog post&lt;/a&gt;' in response.content)</span></code></pre>
<pre><code>
Yo<span class="string">u'll also need to add the following at the top:

``` python blogengine/tests.py
import markdown</code></pre>
<p>What we do here is we convert our post text to include a link using Markdown. We also need to render that post in markdown within the test so that what we have in the test matches what will be produced - otherwise our test will be broken. We also check that the link is marked up correctly.</p>
<p>Save the file and run the tests - they should fail. Now, create the following directory and file:</p>
<pre><code class="lang-bash">mkdir blogengine/templatetags
touch blogengine/templatetags/__init__.py</code></pre>
<p>Note that the <code>__init__.py</code> file is meant to be blank.</p>
<p>Then create the following file and edit it to look like this:</p>
<p>``` python blogengine/templatetags/custom_markdown.py
import markdown</p>
<p>from django import template
from django.template.defaultfilters import stringfilter
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe</p>
<p>register = template.Library()</p>
<p>@register.filter(is_safe=True)
@stringfilter
def custom_markdown(value):
    extensions = [&quot;nl2br&quot;, ]</p>
<pre><code><span class="keyword">return</span> mark_safe(markdown.markdown(force_unicode(value),
                                   extensions,
                                   safe_mode=<span class="keyword">True</span>,
                                   enable_attributes=<span class="keyword">False</span>))</code></pre>
<pre><code>
Then just amend the post list template to use it:

``` html templates/blogengine/post_list.html
<span class="template_tag">{% raw %}</span><span class="template_tag">{% <span class="keyword">extends</span> "blogengine/includes/base.html" %}</span>

    <span class="template_tag">{% <span class="keyword">load</span> custom_markdown %}</span>

    <span class="template_tag">{% <span class="keyword">block</span> content %}</span>
        <span class="template_tag">{% <span class="keyword">for</span> post <span class="keyword">in</span> object_list %}</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="variable">{{ post.title }}</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h3</span>&gt;</span><span class="variable">{{ post.pub_date }}</span><span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
        <span class="variable">{{ post.text<span class="filter">|custom</span>_markdown }}</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endfor</span> %}</span>
    <span class="template_tag">{% <span class="keyword">endblock</span> %}</span><span class="template_tag">{% endraw %}</span></code></pre>
<p>It&#39;s that easy to use a custom markup system with your blog!</p>
<p>Let&#39;s commit the changes:</p>
<pre><code class="lang-bash">git add requirements.txt templates/ blogengine/
git commit -m <span class="string">'Added Markdown support'</span></code></pre>
<h2 id="pagination">Pagination</h2>
<p>As at right now, all of our posts are displayed on the index page. We want to fix that by implementing pagination. Fortunately, that&#39;s very easy for us because we&#39;re using Django&#39;s generic views. Go into <code>blogengine/urls.py</code> and amend it as follows:</p>
<p>``` python blogengine/urls.py
from django.conf.urls import patterns, url
from django.views.generic import ListView
from blogengine.models import Post</p>
<p>urlpatterns = patterns(&#39;&#39;,</p>
<pre><code><span class="comment"># Index</span>
url(<span class="string">r'^(?P&lt;page&gt;\d+)?/?$'</span>, ListView.as_view(
    model=Post,
    paginate_by=<span class="number">5</span>,
    )),</code></pre>
<p>)</p>
<pre><code>
That will automatically paginate our posts by 5 - feel free to change the value of `paginate_by` if you wish. However, we need to place the links in our template as well:

``` html templates/blogengine/post_list.html
<span class="template_tag">{% raw %}</span><span class="template_tag">{% <span class="keyword">extends</span> "blogengine/includes/base.html" %}</span>

    <span class="template_tag">{% <span class="keyword">load</span> custom_markdown %}</span>

    <span class="template_tag">{% <span class="keyword">block</span> content %}</span>
        <span class="template_tag">{% <span class="keyword">for</span> post <span class="keyword">in</span> object_list %}</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="variable">{{ post.title }}</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h3</span>&gt;</span><span class="variable">{{ post.pub_date }}</span><span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
        <span class="variable">{{ post.text<span class="filter">|custom</span>_markdown }}</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endfor</span> %}</span>

        <span class="template_tag">{% <span class="keyword">if</span> page_obj.has_previous %}</span>
        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/<span class="variable">{{ page_obj.previous_page_number }}</span>/"</span>&gt;</span>Previous Page<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endif</span> %}</span>
        <span class="template_tag">{% <span class="keyword">if</span> page_obj.has_next %}</span>
        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/<span class="variable">{{ page_obj.next_page_number }}</span>/"</span>&gt;</span>Next Page<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endif</span> %}</span>

    <span class="template_tag">{% <span class="keyword">endblock</span> %}</span><span class="template_tag">{% endraw %}</span></code></pre>
<p>Try adding a few more blog posts, and you&#39;ll see the pagination links. But give them a try, and they won&#39;t work. Why not? Well, as it turns out there was a bug in the project-wide <code>urls.py</code> file (my bad!). Let&#39;s fix that:</p>
<p>``` python django_tutorial_blog_ng/urls.py
from django.conf.urls import patterns, include, url</p>
<p>from django.contrib import admin
admin.autodiscover()</p>
<p>urlpatterns = patterns(&#39;&#39;,</p>
<pre><code><span class="comment"># Examples:</span>
<span class="comment"># url(r'^$', 'django_tutorial_blog_ng.views.home', name='home'),</span>
<span class="comment"># url(r'^blog/', include('blog.urls')),</span>

url(<span class="string">r'^admin/'</span>, include(admin.site.urls)),

<span class="comment"># Blog URLs</span>
url(<span class="string">r''</span>, include(<span class="string">'blogengine.urls'</span>)),</code></pre>
<p>)</p>
<pre><code>
If you <span class="keyword">try</span> again, yo<span class="string">u'll see that the `blogengine` app now happily deals with the paginated posts. Let'</span>s commit our changes:

``` bash
git add blogengine/ django_tutorial_blog_ng/ templates/
git commit -m <span class="string">'Implemented pagination'</span></code></pre>
<h2 id="viewing-individual-posts">Viewing individual posts</h2>
<p>As our last task for today, we&#39;ll implement individual pages for each post. We want each post to have a nice, friendly URL that is as human-readable as possible, and also includes the date the post was created.</p>
<p>First of all, we&#39;ll implement our test for it, however:</p>
<p>``` python blogengine/tests.py
    def test_post_page(self):</p>
<pre><code>    # Create the post
    post = Post()
    post.title = <span class="comment">'My first post'</span>
    post.text = <span class="comment">'This is [my first blog post](http://127.0.0.1:8000/)'</span>
    post.pub_date = timezone.<span class="built_in">now</span>()
    post.save()

    # Check <span class="keyword">new</span> post saved
    all_posts = Post.objects.all()
    self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)
    only_post = all_posts[<span class="number">0</span>]
    self.assertEquals(only_post, post)

    # <span class="keyword">Get</span> the post URL
    post_url = only_post.get_absolute_url()

    # Fetch the post
    <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(post_url)
    self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

    # Check the post title <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(post.title <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post text <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(markdown.markdown(post.text) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post <span class="built_in">date</span> <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">year</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)
    self.assertTrue(post.pub_date.strftime(<span class="comment">'%b') in response.content)</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">day</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the link <span class="keyword">is</span> marked up properly
    self.assertTrue(<span class="comment">'&lt;a href="http://127.0.0.1:8000/"&gt;my first blog post&lt;/a&gt;' in response.content)</span></code></pre>
<pre><code>
Add this method <span class="keyword">to</span> <span class="keyword">the</span> `PostViewTest` <span class="type">class</span>, <span class="keyword">after</span> `test_index`. It's very similar <span class="keyword">to</span> `test_index`, <span class="keyword">since</span> <span class="keyword">it</span>'s testing much <span class="keyword">the</span> same content. However, <span class="keyword">not</span> <span class="keyword">that</span> we fetch <span class="keyword">the</span> post-specific URL using <span class="keyword">the</span> method `get_absolute_url`, <span class="keyword">and</span> we <span class="keyword">then</span> fetch <span class="keyword">that</span> page.

Now, <span class="keyword">if</span> you <span class="command">run</span> <span class="keyword">the</span> test, <span class="keyword">it</span> will fail because `get_absolute_url` <span class="keyword">isn't</span> implemented. It's often a good idea <span class="keyword">to</span> have a `get_absolute_url` method <span class="keyword">for</span> your models, which defines a single URL scheme <span class="keyword">for</span> <span class="keyword">that</span> type <span class="keyword">of</span> object. So let's create one. However, <span class="keyword">to</span> implement our URL scheme we need <span class="keyword">to</span> make <span class="keyword">some</span> changes. Right now we have <span class="keyword">the</span> <span class="type">date</span>, <span class="keyword">but</span> we don't have a <span class="type">text</span> <span class="type">string</span> we can use, known <span class="keyword">in</span> Django <span class="keyword">as</span> a *slug*. So we'll add a slug field, which will be prepopulated based <span class="function_start"><span class="keyword">on</span> <span class="title">the</span></span> post title. Edit your model <span class="keyword">as</span> follows:

``` python blogengine/models.py
<span class="keyword">from</span> django.db import models

<span class="comment"># Create your models here.</span>
<span class="type">class</span> Post(models.Model):
    title = models.CharField(max_length=<span class="number">200</span>)
    pub_date = models.DateTimeField()
    <span class="type">text</span> = models.TextField()
    slug = models.SlugField(max_length=<span class="number">40</span>, unique=True)

    def get_absolute_url(self):
<span class="command">        return</span> <span class="string">"/%s/%s/%s/"</span> % (self.pub_date.<span class="property">year</span>, self.pub_date.<span class="property">month</span>, self.slug)

    def __unicode__(self):
<span class="command">        return</span> self.title

    <span class="type">class</span> Meta:
        ordering = [<span class="string">"-pub_date"</span>]</code></pre>
<p>Here we&#39;ve added a slug field to the model, as well as implementing our <code>get_absolute_url</code> method. Note we&#39;ve limited the date to year and month, but you can include days if you wish.</p>
<p>While we&#39;re in here, we&#39;ve also implemented the <code>__unicode__</code> method. Essentially, this sets how Django describes the object in the admin - in this case, the post title is a logical way of describing that <code>Post</code> object, so it returns the post title.</p>
<p>We&#39;ve also added the class Meta, with the ordering field. This tells Django that by default any list of posts should return them ordered by <code>pub_date</code> in reverse - in other words, latest first.</p>
<p>To have the slug filled in automatically, we need to customise the admin interface a little as well:</p>
<p>``` python blogengine/admin.py
import models
from django.contrib import admin</p>
<p>class PostAdmin(admin.ModelAdmin):
    prepopulated_fields = {&quot;slug&quot;: (&quot;title&quot;,)}</p>
<p>admin.site.register(models.Post, PostAdmin)</p>
<pre><code>
Now, I recommend <span class="keyword">at</span> this stage going <span class="keyword">into</span> <span class="keyword">the</span> admin <span class="keyword">and</span> deleting all <span class="keyword">of</span> your posts, because otherwise you'll have problems <span class="keyword">in</span> migrating them. The issue <span class="keyword">is</span> <span class="keyword">that</span> each slug <span class="keyword">is</span> compulsory <span class="keyword">and</span> must be unique, <span class="keyword">and</span> <span class="keyword">it</span>'s <span class="keyword">not</span> practical <span class="keyword">to</span> use South <span class="keyword">to</span> automatically generate new slugs <span class="keyword">from</span> <span class="keyword">the</span> title <span class="function_start"><span class="keyword">on</span> <span class="title">the</span></span> fly, so <span class="keyword">by</span> deleting them <span class="keyword">at</span> this stage you'll avoid problems. Once <span class="keyword">that</span>'s done, <span class="command">run</span> this command:

``` bash
python manage.py schemamigration <span class="comment">--auto blogengine</span></code></pre>
<p>You&#39;ll be prompted to specify a one-off default value - enter any string you like, such as &quot;blah&quot;. Then run the migration:</p>
<pre><code class="lang-bash">python manage.py migrate</code></pre>
<p>Let&#39;s run our tests now:</p>
<pre><code class="lang-bash">(venv)Smith:django_tutorial_blog_ng matthewdaly$ python manage.py test
Creating test database <span class="keyword">for</span> alias <span class="string">'default'</span>...
.F.F...F
======================================================================
FAIL: test_create_post (blogengine.tests.AdminTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File <span class="string">"/Users/matthewdaly/Projects/django_tutorial_blog_ng/blogengine/tests.py"</span>, line 103, <span class="keyword">in</span> test_create_post
    self.assertTrue(<span class="string">'added successfully'</span> <span class="keyword">in</span> response.content)
AssertionError: False is not <span class="literal">true</span>

======================================================================
FAIL: test_edit_post (blogengine.tests.AdminTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File <span class="string">"/Users/matthewdaly/Projects/django_tutorial_blog_ng/blogengine/tests.py"</span>, line 132, <span class="keyword">in</span> test_edit_post
    self.assertTrue(<span class="string">'changed successfully'</span> <span class="keyword">in</span> response.content)
AssertionError: False is not <span class="literal">true</span>

======================================================================
FAIL: test_post_page (blogengine.tests.PostViewTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File <span class="string">"/Users/matthewdaly/Projects/django_tutorial_blog_ng/blogengine/tests.py"</span>, line 222, <span class="keyword">in</span> test_post_page
    self.assertEquals(response.status_code, 200)
AssertionError: 404 != 200

----------------------------------------------------------------------
Ran 8 tests <span class="keyword">in</span> 2.180s

FAILED (failures=3)
Destroying test database <span class="keyword">for</span> alias <span class="string">'default'</span>...</code></pre>
<p>Whoops! Our tests are broken, because the slug field isn&#39;t being filled in. If you take a look at the page for adding a post, you&#39;ll notice that the slug is filled in using JavaScript, so our test fails because the test client doesn&#39;t interpret JavaScript. So in the tests we have to fill in the slug field manually.</p>
<p>Also, for the unit tests, the slug attribute isn&#39;t being created at all, so it can&#39;t be saved. Let&#39;s remedy that. First, edit the <code>test_create_post</code> method of <code>PostTest</code>:</p>
<p>``` python blogengine/tests.py
class PostTest(TestCase):
    def test_create_post(self):</p>
<pre><code>    <span class="comment"># Create the post</span>
    post = Post()

    <span class="comment"># Set the attributes</span>
    post.title = 'My <span class="keyword">first</span> post'
    post.<span class="type">text</span> = 'This <span class="keyword">is</span> <span class="keyword">my</span> <span class="keyword">first</span> blog post'
    post.slug = '<span class="keyword">my</span>-<span class="keyword">first</span>-post'
    post.pub_date = timezone.now()

    <span class="comment"># Save it</span>
    post.save()

    <span class="comment"># Check we can find it</span>
    all_posts = Post.objects.all()
    self.assertEquals(len(all_posts), <span class="number">1</span>)
    only_post = all_posts[<span class="number">0</span>]
    self.assertEquals(only_post, post)

    <span class="comment"># Check attributes</span>
    self.assertEquals(only_post.title, 'My <span class="keyword">first</span> post')
    self.assertEquals(only_post.<span class="type">text</span>, 'This <span class="keyword">is</span> <span class="keyword">my</span> <span class="keyword">first</span> blog post')
    self.assertEquals(only_post.slug, '<span class="keyword">my</span>-<span class="keyword">first</span>-post')
    self.assertEquals(only_post.pub_date.<span class="property">day</span>, post.pub_date.<span class="property">day</span>)
    self.assertEquals(only_post.pub_date.<span class="property">month</span>, post.pub_date.<span class="property">month</span>)
    self.assertEquals(only_post.pub_date.<span class="property">year</span>, post.pub_date.<span class="property">year</span>)
    self.assertEquals(only_post.pub_date.hour, post.pub_date.hour)
    self.assertEquals(only_post.pub_date.minute, post.pub_date.minute)
    self.assertEquals(only_post.pub_date.<span class="keyword">second</span>, post.pub_date.<span class="keyword">second</span>)</code></pre>
<pre><code>
<span class="keyword">Next</span>, <span class="keyword">let</span><span class="comment">'s amend `AdminTest`:</span>

``` python blogengine/tests.py
<span class="keyword">class</span> AdminTest(LiveServerTestCase):
    fixtures = [<span class="comment">'users.json']</span>

    def setUp(self):
        self.client = Client()

    def test_login(self):
        # <span class="keyword">Get</span> login page
        <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/admin/')</span>

        # Check <span class="built_in">response</span> code
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check <span class="comment">'Log in' in response</span>
        self.assertTrue(<span class="comment">'Log in' in response.content)</span>

        # <span class="built_in">Log</span> the user <span class="keyword">in</span>
        self.client.login(username=<span class="comment">'bobsmith', password="password")</span>

        # Check <span class="built_in">response</span> code
        <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/admin/')</span>
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check <span class="comment">'Log out' in response</span>
        self.assertTrue(<span class="comment">'Log out' in response.content)</span>

    def test_logout(self):
        # <span class="built_in">Log</span> <span class="keyword">in</span>
        self.client.login(username=<span class="comment">'bobsmith', password="password")</span>

        # Check <span class="built_in">response</span> code
        <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/admin/')</span>
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check <span class="comment">'Log out' in response</span>
        self.assertTrue(<span class="comment">'Log out' in response.content)</span>

        # <span class="built_in">Log</span> out
        self.client.logout()

        # Check <span class="built_in">response</span> code
        <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/admin/')</span>
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check <span class="comment">'Log in' in response</span>
        self.assertTrue(<span class="comment">'Log in' in response.content)</span>

    def test_create_post(self):
        # <span class="built_in">Log</span> <span class="keyword">in</span>
        self.client.login(username=<span class="comment">'bobsmith', password="password")</span>

        # Check <span class="built_in">response</span> code
        <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/admin/blogengine/post/add/')</span>
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Create the <span class="keyword">new</span> post
        <span class="built_in">response</span> = self.client.post(<span class="comment">'/admin/blogengine/post/add/', {</span>
            <span class="comment">'title': 'My first post',</span>
            <span class="comment">'text': 'This is my first post',</span>
            <span class="comment">'pub_date_0': '2013-12-28',</span>
            <span class="comment">'pub_date_1': '22:00:04',</span>
            <span class="comment">'slug': 'my-first-post'</span>
        },
        follow=<span class="literal">True</span>
        )
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check added successfully
        self.assertTrue(<span class="comment">'added successfully' in response.content)</span>

        # Check <span class="keyword">new</span> post <span class="built_in">now</span> <span class="keyword">in</span> database
        all_posts = Post.objects.all()
        self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)

    def test_edit_post(self):
        # Create the post
        post = Post()
        post.title = <span class="comment">'My first post'</span>
        post.text = <span class="comment">'This is my first blog post'</span>
        post.slug = <span class="comment">'my-first-post'</span>
        post.pub_date = timezone.<span class="built_in">now</span>()
        post.save()

        # <span class="built_in">Log</span> <span class="keyword">in</span>
        self.client.login(username=<span class="comment">'bobsmith', password="password")</span>

        # Edit the post
        <span class="built_in">response</span> = self.client.post(<span class="comment">'/admin/blogengine/post/1/', {</span>
            <span class="comment">'title': 'My second post',</span>
            <span class="comment">'text': 'This is my second blog post',</span>
            <span class="comment">'pub_date_0': '2013-12-28',</span>
            <span class="comment">'pub_date_1': '22:00:04',</span>
            <span class="comment">'slug': 'my-second-post'</span>
        },
        follow=<span class="literal">True</span>
        )
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check changed successfully
        self.assertTrue(<span class="comment">'changed successfully' in response.content)</span>

        # Check post amended
        all_posts = Post.objects.all()
        self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)
        only_post = all_posts[<span class="number">0</span>]
        self.assertEquals(only_post.title, <span class="comment">'My second post')</span>
        self.assertEquals(only_post.text, <span class="comment">'This is my second blog post')</span>

    def test_delete_post(self):
        # Create the post
        post = Post()
        post.title = <span class="comment">'My first post'</span>
        post.text = <span class="comment">'This is my first blog post'</span>
        post.slug = <span class="comment">'my-first-post'</span>
        post.pub_date = timezone.<span class="built_in">now</span>()
        post.save()

        # Check <span class="keyword">new</span> post saved
        all_posts = Post.objects.all()
        self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)

        # <span class="built_in">Log</span> <span class="keyword">in</span>
        self.client.login(username=<span class="comment">'bobsmith', password="password")</span>

        # Delete the post
        <span class="built_in">response</span> = self.client.post(<span class="comment">'/admin/blogengine/post/1/delete/', {</span>
            <span class="comment">'post': 'yes'</span>
        }, follow=<span class="literal">True</span>)
        self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

        # Check deleted successfully
        self.assertTrue(<span class="comment">'deleted successfully' in response.content)</span>

        # Check post amended
        all_posts = Post.objects.all()
        self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">0</span>)</code></pre>
<p>And <code>PostViewTest</code>:</p>
<p>``` python blogengine/tests.py
class PostViewTest(LiveServerTestCase):
    def setUp(self):
        self.client = Client()</p>
<pre><code>def test_index(self):
    # Create the post
    post = Post()
    post.title = <span class="comment">'My first post'</span>
    post.text = <span class="comment">'This is [my first blog post](http://127.0.0.1:8000/)'</span>
    post.slug = <span class="comment">'my-first-post'</span>
    post.pub_date = timezone.<span class="built_in">now</span>()
    post.save()

    # Check <span class="keyword">new</span> post saved
    all_posts = Post.objects.all()
    self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)

    # Fetch the index
    <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(<span class="comment">'/')</span>
    self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

    # Check the post title <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(post.title <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post text <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(markdown.markdown(post.text) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post <span class="built_in">date</span> <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">year</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)
    self.assertTrue(post.pub_date.strftime(<span class="comment">'%b') in response.content)</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">day</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the link <span class="keyword">is</span> marked up properly
    self.assertTrue(<span class="comment">'&lt;a href="http://127.0.0.1:8000/"&gt;my first blog post&lt;/a&gt;' in response.content)</span>

def test_post_page(self):
    # Create the post
    post = Post()
    post.title = <span class="comment">'My first post'</span>
    post.text = <span class="comment">'This is [my first blog post](http://127.0.0.1:8000/)'</span>
    post.slug = <span class="comment">'my-first-post'</span>
    post.pub_date = timezone.<span class="built_in">now</span>()
    post.save()

    # Check <span class="keyword">new</span> post saved
    all_posts = Post.objects.all()
    self.assertEquals(<span class="built_in">len</span>(all_posts), <span class="number">1</span>)
    only_post = all_posts[<span class="number">0</span>]
    self.assertEquals(only_post, post)

    # <span class="keyword">Get</span> the post URL
    post_url = only_post.get_absolute_url()

    # Fetch the post
    <span class="built_in">response</span> = self.client.<span class="keyword">get</span>(post_url)
    self.assertEquals(<span class="built_in">response</span>.status_code, <span class="number">200</span>)

    # Check the post title <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(post.title <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post text <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(markdown.markdown(post.text) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the post <span class="built_in">date</span> <span class="keyword">is</span> <span class="keyword">in</span> the <span class="built_in">response</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">year</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)
    self.assertTrue(post.pub_date.strftime(<span class="comment">'%b') in response.content)</span>
    self.assertTrue(str(post.pub_date.<span class="built_in">day</span>) <span class="keyword">in</span> <span class="built_in">response</span>.content)

    # Check the link <span class="keyword">is</span> marked up properly
    self.assertTrue(<span class="comment">'&lt;a href="http://127.0.0.1:8000/"&gt;my first blog post&lt;/a&gt;' in response.content)</span></code></pre>
<pre><code>
What we're doing here <span class="keyword">is</span> <span class="keyword">that</span> <span class="keyword">every</span> <span class="property">time</span> we create a Post object programmatically, we add <span class="keyword">the</span> `post.slug` atttribute <span class="keyword">to</span> <span class="keyword">it</span>. Also, when submitting a post via <span class="keyword">the</span> admin, we pass <span class="keyword">the</span> `slug` parameter via HTTP POST, thus emulating how a form would submit this data.

If you <span class="command">run</span> <span class="keyword">the</span> tests again, you'll see <span class="keyword">that</span> `test_post_page` still fails. This <span class="keyword">is</span> because we haven't yet up <span class="keyword">the</span> URLs, templates <span class="keyword">and</span> views <span class="keyword">to</span> do so. Let's fix <span class="keyword">that</span>. We'll use another generic view, called a DetailView, <span class="keyword">to</span> display <span class="keyword">the</span> posts. Amend `blogengine/urls.py` <span class="keyword">as</span> follows:

``` python blogengine/urls.py
rom django.conf.urls import patterns, url
<span class="keyword">from</span> django.views.generic import ListView, DetailView
<span class="keyword">from</span> blogengine.models import Post

urlpatterns = patterns('',
    <span class="comment"># Index</span>
    url(r'^(?P&lt;page&gt;\d+)?/?$', ListView.as_view(
        model=Post,
        paginate_by=<span class="number">5</span>,
        )),

    <span class="comment"># Individual posts</span>
    url(r'^(?P&lt;pub_date__year&gt;\d{<span class="number">4</span>})/(?P&lt;pub_date__month&gt;\d{<span class="number">1</span>,<span class="number">2</span>})/(?P&lt;slug&gt;[a-zA-Z0-<span class="number">9</span>-]+)/?$', DetailView.as_view(
        model=Post,
        )),
)</code></pre>
<p>Running our tests again will still fail, but now because the template <code>post_detail.html</code> has not been found. So let&#39;s create it:</p>
<p>``` html templates/blogengine/post_detail.html
{% raw %}{% extends &quot;blogengine/includes/base.html&quot; %}</p>
<pre><code><span class="template_tag">{% <span class="keyword">load</span> custom_markdown %}</span>

<span class="template_tag">{% <span class="keyword">block</span> content %}</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="variable">{{ object.title }}</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h3</span>&gt;</span><span class="variable">{{ object.pub_date }}</span><span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
    <span class="variable">{{ object.text<span class="filter">|custom</span>_markdown }}</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<p>{% endblock %}{% endraw %}</p>
<pre><code>
If you run your tests again, they should now pass. However, we still need to provide a hyperlink from each post in the index to the post page, so let's do that:

``` html templates/blogengine/post_list.html
<span class="template_tag">{% raw %}</span><span class="template_tag">{% <span class="keyword">extends</span> "blogengine/includes/base.html" %}</span>

    <span class="template_tag">{% <span class="keyword">load</span> custom_markdown %}</span>

    <span class="template_tag">{% <span class="keyword">block</span> content %}</span>
        <span class="template_tag">{% <span class="keyword">for</span> post <span class="keyword">in</span> object_list %}</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"<span class="variable">{{ post.get_absolute_url }}</span>"</span>&gt;</span><span class="variable">{{ post.title }}</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h3</span>&gt;</span><span class="variable">{{ post.pub_date }}</span><span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
        <span class="variable">{{ post.text<span class="filter">|custom</span>_markdown }}</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endfor</span> %}</span>

        <span class="template_tag">{% <span class="keyword">if</span> page_obj.has_previous %}</span>
        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/<span class="variable">{{ page_obj.previous_page_number }}</span>/"</span>&gt;</span>Previous Page<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endif</span> %}</span>
        <span class="template_tag">{% <span class="keyword">if</span> page_obj.has_next %}</span>
        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/<span class="variable">{{ page_obj.next_page_number }}</span>/"</span>&gt;</span>Next Page<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="template_tag">{% <span class="keyword">endif</span> %}</span>

    <span class="template_tag">{% <span class="keyword">endblock</span> %}</span><span class="template_tag">{% endraw %}</span></code></pre>
<p>And that&#39;s all for today! We now have individual post pages, we&#39;ve styled our blog a bit, and we&#39;ve implemented Markdown support. All that remains is to commit our changes:</p>
<pre><code class="lang-bash">git add blogengine/ templates/
git commit -m <span class="string">'Implemented post pages'</span></code></pre>
<p>As before, I&#39;ve tagged the final commit with &#39;lesson-2&#39;, so if you&#39;re following along, you can switch to this point with <code>git checkout lesson-2</code>.</p>
<p>Next time we&#39;ll add support for flat pages and multiple authors, as well as adding support for comments via a third-party commenting system.</p>

  </section>
    <section>
        <p>
          2nd January 2014
          
            by Matthew Daly
          
        </p>
    </section>

  <ul class="pager">
      
        <li><a href="/posts/2014-01-03-django-blog-tutorial-the-next-generation-part-3.html">Newer</a></li>
      
      
        <li><a href="/posts/2013-12-28-django-blog-tutorial-the-next-generation-part-1.html">Older</a></li>
      
    </ul>
  <section class="comments">
    
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        window.disqus_identifier="";
        window.disqus_url="http://www.matthewdaly.co.uk/posts/2014-01-02-django-blog-tutorial-the-next-generation-part-2.html";
        window.disqus_title="Django blog tutorial - the next generation - part 2";
      </script>
        <script type="text/javascript" src="http://disqus.com/forums/mattbd/embed.js"></script>
        <noscript><a href="http://mattbd.disqus.com/?url=ref">View the discussion thread.</a></noscript>
    
    
  </section>
</article>

        </div>

        <footer>
            <div class="container">
                Copyright Matthew Daly, 2014.
            </div>
        </footer>
        <script type="text/javascript" src="/static/js/dependencies.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
